
#+title:  Tfg
#+author: Siddharta Morión Suárez

*** 23/03/25 dom
*       Trabajando en implementar una base de datos de postgres que funcione con el servidor
        Primero añadi la config en application.properties y luego borre postgres/data y lo recree con initdb porque una nueva version de postgres habia salido
        y tenia datos de proyectos antiguos que no servian, por lo que no iba a dumpear y restaurar
        asi que un buen rm /var/lib/postgres/data/* y initdb /var/lib/postgres/data y palante
*       Creando una implementación de User
        Extendí la implementación por defecto que trae spring security, ya que no traía campo de email


*** 24/03/25 lun
*       Continuo implementación de User
        Se alarga la tarea debido a poco tiempo y a que la implementación de user tiene bastantes métodos státicos que no puedo sobreescribir, además
        a los que me veo forzado a returnear el builder antiguo, y a no poder returnear el mío. Pero ya queda bastante poco.

*** 29/03/25 sab
*       Termino implementación de User
        Añado métodos personalizados de with* y un extBuilder. Además de crear un ExtUserDetails para poder crear un extWithUserDetails
*       Implementación de un PasswordEncoder
        Me informo de como funcionan los password encoders en spring security y de su uso de SecureRandom
        #+BEGIN_SRC java
            {@link java.security.SecureRandom}
        #+END_SRC
        Posiblemente utilizo la implementación de BcryptPasswordEncoder
        Al final lo que voy a usar es basicamente eso
        #+BEGIN_SRC java
            PasswordEncoder encoder = new BCryptPasswordEncoder();
            String pw = "JuanSecreto";

            pw = encoder.encode(pw);
            ExtUser user = (ExtUser) ExtUser.extWithUsername("Juan")
            .email("Juan@elmejor.com")
            // aquí se usaria un passwordEncoder
            .password(pw)
            .roles("Admin")
            .build();


            System.out.println(user);
        #+END_SRC
*       Estableciendo configuración específica de la db
        Establezco la versión de los contenedores de docker (postgres y adminer) a una versión fija para evitar problemas
        y reestablezco la base de datos, ya que estaba dando problemas al crearse una nueva versión de postgres
        el esquema ER lo tengo en db designer y lo puedo descargar en un .SQL que puedo importar.

        Igualmente cada vez que lo descargo tengo que cambiar las primary keys de datatype porque se ponen en cualquier cosa menos int
        y no quiero ni short ni bigint y cambiar "with timezone" por without ya que, ya tengo user_timezone, un shortint que representa la diferencia de UTC (+1+2-1-2...)

*       Implementación de un UserRep (para despues usarlo con un reactiveUserDetailService)
        He creado una clase de @configuration jdbcConfig para crear un jdbc template creado con el datasource establecido en el application.properties
        Luego he implementado un @Repository UserRep para poder hacer de DAO con los usuarios y usarlo después para un reactiveuserdetailservice

        Al implementarlo me he dado cuenta de que mi clase modelo ExtUser y (por lo tanto su interfaz ExtUserDetails) no tenían soporte para el resto de campos de la base de datos
        como created_at timezone o streamer_id

        por lo que he implementado ese soporte también y el metodo findByUsername en UserRep

        He añadido la dependencia spring-boot-starter-data-jdbc para que el jdbcConfig se cree automaticamente cogiendo el datasource de application.properties, por lo que
        JdbcConfig.java ya no es necesario para nada.

**  01/04/25 (hay dias que no apunto y sobreescribo en lo que hay)
*      Modificación de userService, los métodos que requiere para el contrato UserDetailService deberían recoger el mínimo de info
        Las tablas de las bases de datos se me están quedando muy grandes, no debería coger todas las columnas para buscar por usuario en el userdetailservice
        ya que ese usuario se usa para la autenticación, para esa operación el usuario, la contraseña y las autoridades sobran la verdad.

*       Expansión de ExtUser para añadir notificaciones, suscripciones y seguidores.

**  02/04/25
*      Creación de un ReactiveAuthManager
        En webflux se utiliza como authmanager y authprovider un reactiveAuthManager.
        He usado la impl concreta de un UserDetailsRepositoryReactiveAuthenticationManager;
        #+BEGIN_SRC java
            @Bean
  59 + │    public ReactiveAuthenticationManager authenticationProvider() {
       │        authProvider = new DaoAuthenticationProvider(passwordEncoder());
  60 + │        UserDetailsRepositoryReactiveAuthenticationManager authManager = new UserDetailsRepositoryReactiveAuthenticationManager(CustomUserDetailService);
  61 + │        authManager.setPasswordEncoder(passwordEncoder());
  62 + │        return authManager;
        #+END_SRC
