
#+title:  Tfg
#+author: Siddharta Mori√≥n Su√°rez

*** 23/03/25 dom
*       Trabajando en implementar una base de datos de postgres que funcione con el servidor
        Primero a√±adi la config en application.properties y luego borre postgres/data y lo recree con initdb porque una nueva version de postgres habia salido
        y tenia datos de proyectos antiguos que no servian, por lo que no iba a dumpear y restaurar
        asi que un buen rm /var/lib/postgres/data/* y initdb /var/lib/postgres/data y palante
*       Creando una implementaci√≥n de User
        Extend√≠ la implementaci√≥n por defecto que trae spring security, ya que no tra√≠a campo de email


*** 24/03/25 lun
*       Continuo implementaci√≥n de User
        Se alarga la tarea debido a poco tiempo y a que la implementaci√≥n de user tiene bastantes m√©todos st√°ticos que no puedo sobreescribir, adem√°s
        a los que me veo forzado a returnear el builder antiguo, y a no poder returnear el m√≠o. Pero ya queda bastante poco.

*** 29/03/25 sab
*       Termino implementaci√≥n de User
        A√±ado m√©todos personalizados de with* y un extBuilder. Adem√°s de crear un ExtUserDetails para poder crear un extWithUserDetails
*       Implementaci√≥n de un PasswordEncoder
        Me informo de como funcionan los password encoders en spring security y de su uso de SecureRandom
        #+BEGIN_SRC java
            {@link java.security.SecureRandom}
        #+END_SRC
        Posiblemente utilizo la implementaci√≥n de BcryptPasswordEncoder
        Al final lo que voy a usar es basicamente eso
        #+BEGIN_SRC java
            PasswordEncoder encoder = new BCryptPasswordEncoder();
            String pw = "JuanSecreto";

            pw = encoder.encode(pw);
            ExtUser user = (ExtUser) ExtUser.extWithUsername("Juan")
            .email("Juan@elmejor.com")
            // aqu√≠ se usaria un passwordEncoder
            .password(pw)
            .roles("Admin")
            .build();


            System.out.println(user);
        #+END_SRC
*       Estableciendo configuraci√≥n espec√≠fica de la db
        Establezco la versi√≥n de los contenedores de docker (postgres y adminer) a una versi√≥n fija para evitar problemas
        y reestablezco la base de datos, ya que estaba dando problemas al crearse una nueva versi√≥n de postgres
        el esquema ER lo tengo en db designer y lo puedo descargar en un .SQL que puedo importar.

        Igualmente cada vez que lo descargo tengo que cambiar las primary keys de datatype porque se ponen en cualquier cosa menos int
        y no quiero ni short ni bigint y cambiar "with timezone" por without ya que, ya tengo user_timezone, un shortint que representa la diferencia de UTC (+1+2-1-2...)

*       Implementaci√≥n de un UserRep (para despues usarlo con un reactiveUserDetailService)
        He creado una clase de @configuration jdbcConfig para crear un jdbc template creado con el datasource establecido en el application.properties
        Luego he implementado un @Repository UserRep para poder hacer de DAO con los usuarios y usarlo despu√©s para un reactiveuserdetailservice

        Al implementarlo me he dado cuenta de que mi clase modelo ExtUser y (por lo tanto su interfaz ExtUserDetails) no ten√≠an soporte para el resto de campos de la base de datos
        como created_at timezone o streamer_id

        por lo que he implementado ese soporte tambi√©n y el metodo findByUsername en UserRep

        He a√±adido la dependencia spring-boot-starter-data-jdbc para que el jdbcConfig se cree automaticamente cogiendo el datasource de application.properties, por lo que
        JdbcConfig.java ya no es necesario para nada.

**  01/04/25 (hay dias que no apunto y sobreescribo en lo que hay)
*      Modificaci√≥n de userService, los m√©todos que requiere para el contrato UserDetailService deber√≠an recoger el m√≠nimo de info
        Las tablas de las bases de datos se me est√°n quedando muy grandes, no deber√≠a coger todas las columnas para buscar por usuario en el userdetailservice
        ya que ese usuario se usa para la autenticaci√≥n, para esa operaci√≥n el usuario, la contrase√±a y las autoridades sobran la verdad.

*       Expansi√≥n de ExtUser para a√±adir notificaciones, suscripciones y seguidores.

**  02/04/25
*      Creaci√≥n de un ReactiveAuthManager
        En webflux se utiliza como authmanager y authprovider un reactiveAuthManager.
        He usado la impl concreta de un UserDetailsRepositoryReactiveAuthenticationManager;
        #+BEGIN_SRC java
            @Bean
  59 + ‚îÇ    public ReactiveAuthenticationManager authenticationProvider() {
       ‚îÇ        authProvider = new DaoAuthenticationProvider(passwordEncoder());
  60 + ‚îÇ        UserDetailsRepositoryReactiveAuthenticationManager authManager = new UserDetailsRepositoryReactiveAuthenticationManager(CustomUserDetailService);
  61 + ‚îÇ        authManager.setPasswordEncoder(passwordEncoder());
  62 + ‚îÇ        return authManager;
        #+END_SRC

**  04/04/25
*       Modificaciones base de datos
        Sab√≠as que las contrase√±as encriptadas por bcrypt miden hasta 72 car√°cterres? yo no, la base de datos menos ajajja varchar(50) no hace el avio aqu√≠
        adem√°s si no pones serial no hay autoincremento de las id en postgres, a no ser que hagas una sequence a mano que es lent√≠simo la verdad
*       Cambio de dependencias
        JDBC no est√° hecho para Webflux porque es bloqueante no as√≠ncrono, hace falta RDBC, as√≠ que he cambiado las dependencias en el pom y estoy cambiando JDBCTemplate por DatabaseClient
*       Prueba index.html generado con Angular
        La p√°gina va a ser una SPA que a lo mejor tiene el login y eso por SSR pero el resto no.

**  05/04/25
*       Implementaci√≥n de RDBC por JDBC
        Cambiado application properties, UserService ya no requiere de UserRepository, ya que los m√©todos del Dao directamente returnean el objeto Mono<>
*       Implementaci√≥n de JWT (empezamos)
        Voy a implementar JWT para no necesitar preguntarle al servidor por la identidad del usuario cada vez que necesito su "username"
        adem√°s es bastante seguro y las utilidades que voy a implementar pueden utilizarse despu√©s para implementar oauth2 si lo quisiera.
        Permite una autenticaci√≥n "stateless". (aunque por el momento voy a conservar los tokens de sesi√≥n tambi√©n)
        1. Crear unas keys publicas y privadas en una carpeta /certs dentro de resources
            Adem√°s un archivo config para poder acceder a estos archivos como una clase de java que pueda usar.
            Creo el archivo JwtConfig e inicializo las claves con los comandos mencionados en el issue #8
            luego adem√°s creo los archivos en formato .der para que keyFactory pueda detectarlo.

        Usando @values y ClassPathResource cargo el path de las claves desde un archivo config "JwtConfig"
        y usando java.security cargo las claves del path y las convierto en una clase de java con la que puedo hacer de interfaz

        2. Para gestionar la creaci√≥n y verificaci√≥n de JWS (voy a usar JWS por si no habia quedado claro cuando he hablado de crear un par de claves no es para JWE)
            La librer√≠a en cuesti√≥n es jjwt (java jwt) https://github.com/jwtk/jjwt
            Y voy a implementar una clase muy simple que utilice esta librer√≠a para crear y verficar JWS.
            La clase creada es JwtService.
            Desp√∫es de esto voy a implementar un filtro src_java[:exports code]{code}class JwtAuthenticationFilter extends OncePerRequestFilter}

        3. Crear filtro pero esto ya para ma√±ana, son las 21:30 un s√°bado y estoy en pijama otra vez
**  06/04/25
*       Implementaci√≥n de filtro de SecurityWebFilterChain
        En Spring webflux la clase OncePerRequestFilter no se usa, se usa la interfaz WebFilter, pero hace lo mismo, en vez de pasarle como par√°metros al metodo principal
        (Que en WebFilter se llama filter() en vez de doFilterInternal) request y response se le pasa ServerWebExchange (que es el objeto que representa el intercambio request response)
        y contiene la request, cookies y todo basicamente y la filter chain (como en Oncerper..)  pero se llama webfilterchain, y se hace lo mismo de al final usar la filterchain con filter
        para pasar al siguiente filtro.

       - Implementaci√≥n de un token de authenticacion JwtAuthenticationToken
        He tenido que implementar un JwtAuthenticationToken, que extiende de abstractAuthentication token y lo √∫nico que hace es guardar el token y el usuario (extraido del token)
        ya que en los filtros para que spring boot pueda tomar a un usuario por "autentificado" hay que a√±adir una implementaci√≥n Authorization. Lo mismo que via a tener que hacer en login vamos.
        Esto en laravel era m√°s facil, porque usabas Auth::Attempt y no implementabas manager ninguno pa el token se usaba  $token = $request->user()->createToken($request->token_name);
        y a chuparla. pero bueno aqu√≠ hay que implementar el token si no quieres usar oauth.


       Una vez implementado el filtro y el token necesito ponerlo en la cadena de filtros, para eso uso en http.addFilterBefore(elfiltro, SecurityWebFilterOrder.AUTHENTICATION)
       el securitywebfilterorder es un enum que tiene todas las fases. (menos mal no quer√≠a implementar nada m√°s)


        - Eliminaci√≥n de la sesi√≥n
        Una vez creado un token y un filtro voy a desactivar totalmente las sesiones de spring para que el servidor funcione de verdad sin estado (stateless). Esto en spring boot es muy facil de hacer
        por que puedes poner literalmente .session(STATELESS) pero en webflux hay un issue de github https://github.com/spring-projects/spring-security/issues/6552#issuecomment-519398510 en el que recomiendan cambiar el securityContextRepository a un NoOpServerContextRepository. Eso es lo que he hecho y para que la protecci√≥n de csrf se pueda seguir usando he cambiado el repositorio de csrf a un CookieServerCsrfTokenRepository con httponly.false()  para que lo pueda coger por js cuando est√© usando angular.

        De esta forma la p√°gina de login por defecto no funciona porque no puede guardar la informaci√≥n de autenticaci√≥n en ning√∫n lado. Cuando haga la p√°gina por mi cuenta habra que coger el token por las cookies y o pasarlo como header si hago /login por ajax o a√±adirlo a un input hidden si hago un login por formulario (bloqueante)

**  07/04/25
*       Implementaci√≥n de ruta /login
        Creaci√≥n de un controlador mapeado a la ruta "/login" que realice autenticaci√≥n y si es exitosa cree un token jwt

**  12/04/25
*       Adaptaci√≥n no bloqueante JwtService y JwtAuthenticationFilter
        Durante este tiempo he estado ignorando en ciertas clases que estoy usando webflux y todo lo que utilizo deber√≠a se no bloqueante desde el principio, as√≠ voy a hacer eso.
        Lo que es bloqueante por naturaleza se puede correr en un hilo aparte y lo m√°s recomendado es Mono.fromCallable(funcbloqueante).subscribeOn(Schedulers.boundedElastic()).

        Para hacer un filtro realmente no bloqueante que a√±ada al contexto de seguridad no vale con usar SecurityContextHolder, sino que hay que usar ReactiveSecurityContextHolder.

        Y por lo que se v√© lo recomendado es hacerlo despu√©s de chain.filter(), a ese mono se le encadena .contextWrite (m√©todo de un Mono que a√±ade al contexto de la rutina por as√≠ decirlo) y ReactiveSecurityContextHolder.withSecurityContext(ctx) siendo ctx un new SecurityContextImpl(auth). tiene withAuthorization pero supuestamente es m√°s fiel a spring webflux a√±adir una impl entera.

**  13/04/25
*       Ruta Login totalmente as√≠ncrona
        Pues eso, crea la cookie y la a√±ade a la respuesta, y si falla o la autenticaci√≥n no se puede determinar hace un backflip (returnea 401 unauthorized para verlo con el fetch y hacer .catch)

*       Arreglo bug filtros, JwtAuthenticationFilter
        Resulta que si bloqueo en un filtro de autenticaci√≥n la p√°gina ni renderiza, est√° bien saber que no puedo usar .block(). As√≠ que he arreglado eso y he descubierto que para generar el token de .csrf en las cookies hay que suscribir al exchange.getAttribute(CsrfToken.class.getName()) o returnear la request con un .then en este token o un flatmap (supuestamente ya que flatmap a mi no me va). Para que as√≠ el csrfTokenCookieRepository sepa que tiene que generar una cookie de xsrf

       #+begin_src java

        Mono<ResponseEntity<String>> index(ServerWebExchange exch) {
                // token.defaultIfEmpty(new DefaultCsrfToken("aaa", "aaa", "joder"))
                // .doOnSuccess(csrf -> {
                //         ResponseCookie csrfCookie = ResponseCookie.from(csrf.getHeaderName(), csrf.getToken()).build();
                //         exch.getResponse().addCookie(csrfCookie);
                //     });
                Mono<CsrfToken> csrfToken = exch.getAttribute(CsrfToken.class.getName());
                csrfToken.subscribe();// esto funciona pero a veces tarda el token en estar porque se resuelva as√≠ncrono
                // return csrfToken.then(Mono.just(ResponseEntity.ok("ahi tienes crack"))); // Este es el suyo
                // haz csrfToken.then(lo que quieras hacer) y te aseguras de que el token estar√° listo.
                // return csrfToken.map(token -> {
                //         ResponseCookie csrfCookie = ResponseCookie.from(token.getHeaderName(), token.getToken()).build();
                //         // exch.getResponse().addCookie(csrfCookie);
                //         return ResponseEntity.ok(token.getToken());
                //     });
                return Mono.just(ResponseEntity.ok("aaa"));
       #+end_src

**  14/04/25
*       Ponerlo todo en orden y hacer rutas /api/login /api/register y /api/logout para angular.
        Cuando me sucedio el bug hice un git reset --hard y los cambios anteriores los guard√© en una carpeta aparte, voy a restaurarlos ahora que ya he arreglado que fallaba y a darle ca√±a.
        Archivos restaurados y borrados archivos in√∫tiles

*       Ruta gen√©rica
        Creado un "GlobalController" que forwardee todo a index.html (webflux no tiene forward, as√≠ que cargar manualmente el archivo).
        Como no hay forma de usar un regex que afecte a todos las secciones / / / /. He usado un wildcard y parseados los archivos .css .js, etc manualmente como ClassPathResources
        que se encuentran en static/

        Para las rutas api, crear controladores m√°s espec√≠ficos hace que tengan prioridad.

*       Creados m√©todos createUser(UserDetails) updateTimezone(username, timezone) en UserService
        Hac√≠an falta para register y eso, updateTimezone es para ir quitando camino.
        createUser asume que el email puede ser nulo y solo lo a√±ade al query SQL si el user que se pasa lo tiene. (en el createUser(ExtUserDetails))

*       Creadas rutas api/login y api/register
        Hacen lo que se supone que tienen que hacer pero hay que testearlas para ver si no explotan.
        He cambiado el JwtService para que la cookie de authToken se cree en un m√©todo y evitar repetirme en los controladores.


        Hay que probarlas y hacer el logout tambi√©n.

        ACTUALIZACI√ìN, no funcionan en principio porque el token de csrf se genera con synchronizer pattern, y sin sesion (stateless), esa cookie tiene un valor diferente cada vez si la borras
        sino no te da otra pero el valor cambia.

        La otra forma de hacer protecci√≥n csrf es con el double submit pattern, aunque spring security no lo suportea por su cuenta (no se porque si es mas simple que el caliz).
        (El approach simple)
        Aqu√≠ se explica porque este approach no es seguro del todo para casos en los que un atacante hace MITM, se apodera de un subdominio o encuentra un XSS en un subdominio.
        https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#naive-double-submit-cookie-pattern-discouraged
        #+begin_src java
                @Bean
                public WebFilter csrfCookieGeneratorFilter() {
                        return (exchange, chain) -> {
                                String csrfToken = UUID.randomUUID().toString();

                                ResponseCookie cookie = ResponseCookie.from("XSRF-TOKEN", csrfToken)
                                .httpOnly(false)
                                .path("/")
                                .sameSite("Lax")
                                .build();

                                exchange.getResponse().addCookie(cookie);

                                // Store it in a request attribute for validation later
                                exchange.getAttributes().put("XSRF_TOKEN", csrfToken);

                                return chain.filter(exchange);
                        };
                }
        #+end_src

        Esto envia un nuevo token con cada request. Pero como la valida con la del header da igual, aqu√≠ no va a validarla con una interna
        por lo que no va a dar fallo

        #+begin_src java
                @Bean
                public WebFilter csrfValidatorFilter(exchange, chain) {
                        ServerHttpRequest request = exchange.getRequest();

                        if (request.getMethod().matches("POST|PUT|DELETE")) {
                        String headerToken = request.getHeaders().getFirst("X-XSRF-TOKEN");
                        String cookieToken = request.getCookies().getFirst("XSRF-TOKEN") != null
                                ? request.getCookies().getFirst("XSRF-TOKEN").getValue()
                                : null;

                        if (headerToken == null || cookieToken == null || !headerToken.equals(cookieToken)) {
                            return Mono.error(new AccessDeniedException("Invalid CSRF token"));
                        }

                        return chain.filter(exchange);
                };
        }

        #+end_src
        El cliente simplemente guarda el valor de la cookie y lo manda por el header



*** [15-16/04/25]
*    Arregladas rutas paras que funcionen por completo (no estaban creando correctamente las cookies de auth) y adem√°s creados tests de integraci√≥n para poder probar el registro y el login.
        Basicamente eso, se me olvido ir apunt√°ndolo a medida que lo hac√≠a, adem√°s limpie un poco los m√©todos para que fueran m√°s claros y estuvieran menos identados.
        Me pelee bastante con spring tests pero he conseguido aprender a usarlo. Ahora hay tests que validen la necesidad de un token csrf, tests para comprobar que un registro
        de un usuario ya existente de error, etc.
*    Creada config de seguridad secundaria
        Arreglando el registro me di cuenta de que la contrase√±a no se subia encriptada y al arreglarlo (a√±adiendo el encoder a el servicio de usuario), me encontr√© con un problema de
        dependencias circulares, userService -> SecurityConfig[BCryptPasswordEncoder] -> userService(para el authManager) ->...

        Por lo que cree una config de seguridad diferente y puse el encoder ah√≠.

***  [18/04/25]

*    Creada ruta de logout que sustituye las cookies de user y authtoken por cookies vacias que caducan al segundo.
        Adem√°s creados tests para esa ruta. Que estaban fallando para la ruta logout que requiere auth por el siguiente punto.

*    Corregido JwtAuthenticationFilter:
        Faltaba poner que al crear la auth en mi jwtAuthenticationFilter, se pusiera esa auth como valida con auth.setAuthorized(true). Con un authmanager va solo eso, pero para mi jwtAuthenticationToken
        no hay. as√≠ spring boot permite acceso a las rutas que requieren autorizaci√≥n incluso con noOpContextRepository.

*    A√±adido test de logout con un JWT v√°lido.
        El test es el que me ha permitido arreglar bastantes errores.

*    Creado User flow
        Me falta hacer el wireframe de las p√°ginas m√°s importantes  (welcomepage, feed, login/registro), pensando en el uso de
        componentes de Angular Material y alomejor angular ng

        y poco m√°s de dise√±o. el resto rutas, un design system adaptado a la pagina y eso.
        Dios me haga el usar Angular menos pesado que Spring Security ü§ûü§ûü§û

***  [19/04/25]
*    Creado wireframe detallado de la p√°gina de inicio:
       https://www.figma.com/design/MOY6o8cLVlmN2LrbGbcnAh/Wireframe?node-id=0-1&p=f&t=VCdnnoY2PxkawkQr-0
       Tengo que a√±adir una imagen a una secci√≥n pero por lo dem√°s esta decente. (Probablemente cambie la otra por una de mejor calidad pero no hay cojones a encontrar una con varios deportistas diferentes y m√°s de 3 p√≠xeles).


*    Creado wireframe intermediamente detallado Login y registro
        mismo link para que lo voy a poner otra vez

***   [26/04/25]
*   Creado componente navbar, config Angular proxy y establecidas fuentes.
        Descripci√≥n? Trivago.

***   [27/04/25]
*   Avanzado Landing page y a√±adidos componentes de angular material (tarjeta y lista)
        He a√±adido esos componentes prefabricados de angular material, los cuales no tengo otra que estilizarlos mediante estilos globales (puedes usar el nombre del componente en los selectores ya que contiene al resto de elementos.)

***   [03/05/25]
*   Practicamente terminada la landing page, a√±adido componente 'tabs' para las preguntas frecuentes y contacto
        No hice mucho el sabado la verdad, a√±adi el componente lo complete al principio con unos <detail> para los extensibles y luego para quitar el marcador que se queda (en principio se puede quitar con un selector pero no funciona hoy en d√≠a con la mayor√≠a de los navegadores) lo refactorice en unos divs con la misma funcionalidad.
***   [04/05/25]
*   Cambiado estilo general de Angular Material
        Ahora uso el estilo cyan orange (oscuro) y en el landing he modificado los componentes para conservar tarjetas blancas y otros elementos claros.
*   Hecho dise√±o register
        Usado componente mat-form-field y mat-button. Voy a intentar hacer la interacci√≥n con el backend del registro y aparte el login con la interacci√≥n tambi√©n

*   Creado controlador "debug" CsrfController
        Creado controlador que da acceso a un endpoint de la api con m√©todo GET para poder conseguir un token de csrf desde el servidor de desarrollo de angular.
