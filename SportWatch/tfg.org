
#+title:  Tfg
#+author: Siddharta Morión Suárez

*** 23/03/25 dom
*       Trabajando en implementar una base de datos de postgres que funcione con el servidor
        Primero añadi la config en application.properties y luego borre postgres/data y lo recree con initdb porque una nueva version de postgres habia salido
        y tenia datos de proyectos antiguos que no servian, por lo que no iba a dumpear y restaurar
        asi que un buen rm /var/lib/postgres/data/* y initdb /var/lib/postgres/data y palante
*       Creando una implementación de User
        Extendí la implementación por defecto que trae spring security, ya que no traía campo de email


*** 24/03/25 lun
*       Continuo implementación de User
        Se alarga la tarea debido a poco tiempo y a que la implementación de user tiene bastantes métodos státicos que no puedo sobreescribir, además
        a los que me veo forzado a returnear el builder antiguo, y a no poder returnear el mío. Pero ya queda bastante poco.

*** 29/03/25 sab
*       Termino implementación de User
        Añado métodos personalizados de with* y un extBuilder. Además de crear un ExtUserDetails para poder crear un extWithUserDetails
*       Implementación de un PasswordEncoder
        Me informo de como funcionan los password encoders en spring security y de su uso de SecureRandom
        #+BEGIN_SRC java
            {@link java.security.SecureRandom}
        #+END_SRC
        Posiblemente utilizo la implementación de BcryptPasswordEncoder
        Al final lo que voy a usar es basicamente eso
        #+BEGIN_SRC java
            PasswordEncoder encoder = new BCryptPasswordEncoder();
            String pw = "JuanSecreto";

            pw = encoder.encode(pw);
            ExtUser user = (ExtUser) ExtUser.extWithUsername("Juan")
            .email("Juan@elmejor.com")
            // aquí se usaria un passwordEncoder
            .password(pw)
            .roles("Admin")
            .build();


            System.out.println(user);
        #+END_SRC
*       Estableciendo configuración específica de la db
        Establezco la versión de los contenedores de docker (postgres y adminer) a una versión fija para evitar problemas
        y reestablezco la base de datos, ya que estaba dando problemas al crearse una nueva versión de postgres
        el esquema ER lo tengo en db designer y lo puedo descargar en un .SQL que puedo importar.

        Igualmente cada vez que lo descargo tengo que cambiar las primary keys de datatype porque se ponen en cualquier cosa menos int
        y no quiero ni short ni bigint y cambiar "with timezone" por without ya que, ya tengo user_timezone, un shortint que representa la diferencia de UTC (+1+2-1-2...)

*       Implementación de un UserRep (para despues usarlo con un reactiveUserDetailService)
        He creado una clase de @configuration jdbcConfig para crear un jdbc template creado con el datasource establecido en el application.properties
        Luego he implementado un @Repository UserRep para poder hacer de DAO con los usuarios y usarlo después para un reactiveuserdetailservice

        Al implementarlo me he dado cuenta de que mi clase modelo ExtUser y (por lo tanto su interfaz ExtUserDetails) no tenían soporte para el resto de campos de la base de datos
        como created_at timezone o streamer_id

        por lo que he implementado ese soporte también y el metodo findByUsername en UserRep

        He añadido la dependencia spring-boot-starter-data-jdbc para que el jdbcConfig se cree automaticamente cogiendo el datasource de application.properties, por lo que
        JdbcConfig.java ya no es necesario para nada.

**  01/04/25 (hay dias que no apunto y sobreescribo en lo que hay)
*      Modificación de userService, los métodos que requiere para el contrato UserDetailService deberían recoger el mínimo de info
        Las tablas de las bases de datos se me están quedando muy grandes, no debería coger todas las columnas para buscar por usuario en el userdetailservice
        ya que ese usuario se usa para la autenticación, para esa operación el usuario, la contraseña y las autoridades sobran la verdad.

*       Expansión de ExtUser para añadir notificaciones, suscripciones y seguidores.

**  02/04/25
*      Creación de un ReactiveAuthManager
        En webflux se utiliza como authmanager y authprovider un reactiveAuthManager.
        He usado la impl concreta de un UserDetailsRepositoryReactiveAuthenticationManager;
        #+BEGIN_SRC java
            @Bean
  59 + │    public ReactiveAuthenticationManager authenticationProvider() {
       │        authProvider = new DaoAuthenticationProvider(passwordEncoder());
  60 + │        UserDetailsRepositoryReactiveAuthenticationManager authManager = new UserDetailsRepositoryReactiveAuthenticationManager(CustomUserDetailService);
  61 + │        authManager.setPasswordEncoder(passwordEncoder());
  62 + │        return authManager;
        #+END_SRC

**  04/04/25
*       Modificaciones base de datos
        Sabías que las contraseñas encriptadas por bcrypt miden hasta 72 carácterres? yo no, la base de datos menos ajajja varchar(50) no hace el avio aquí
        además si no pones serial no hay autoincremento de las id en postgres, a no ser que hagas una sequence a mano que es lentísimo la verdad
*       Cambio de dependencias
        JDBC no está hecho para Webflux porque es bloqueante no asíncrono, hace falta RDBC, así que he cambiado las dependencias en el pom y estoy cambiando JDBCTemplate por DatabaseClient
*       Prueba index.html generado con Angular
        La página va a ser una SPA que a lo mejor tiene el login y eso por SSR pero el resto no.

**  05/04/25
*       Implementación de RDBC por JDBC
        Cambiado application properties, UserService ya no requiere de UserRepository, ya que los métodos del Dao directamente returnean el objeto Mono<>
*       Implementación de JWT (empezamos)
        Voy a implementar JWT para no necesitar preguntarle al servidor por la identidad del usuario cada vez que necesito su "username"
        además es bastante seguro y las utilidades que voy a implementar pueden utilizarse después para implementar oauth2 si lo quisiera.
        Permite una autenticación "stateless". (aunque por el momento voy a conservar los tokens de sesión también)
        1. Crear unas keys publicas y privadas en una carpeta /certs dentro de resources
            Además un archivo config para poder acceder a estos archivos como una clase de java que pueda usar.
            Creo el archivo JwtConfig e inicializo las claves con los comandos mencionados en el issue #8
            luego además creo los archivos en formato .der para que keyFactory pueda detectarlo.

        Usando @values y ClassPathResource cargo el path de las claves desde un archivo config "JwtConfig"
        y usando java.security cargo las claves del path y las convierto en una clase de java con la que puedo hacer de interfaz

        2. Para gestionar la creación y verificación de JWS (voy a usar JWS por si no habia quedado claro cuando he hablado de crear un par de claves no es para JWE)
            La librería en cuestión es jjwt (java jwt) https://github.com/jwtk/jjwt
            Y voy a implementar una clase muy simple que utilice esta librería para crear y verficar JWS.
            La clase creada es JwtService.
            Despúes de esto voy a implementar un filtro src_java[:exports code]{code}class JwtAuthenticationFilter extends OncePerRequestFilter}

        3. Crear filtro pero esto ya para mañana, son las 21:30 un sábado y estoy en pijama otra vez
**  06/04/25
*       Implementación de filtro de SecurityWebFilterChain
        En Spring webflux la clase OncePerRequestFilter no se usa, se usa la interfaz WebFilter, pero hace lo mismo, en vez de pasarle como parámetros al metodo principal
        (Que en WebFilter se llama filter() en vez de doFilterInternal) request y response se le pasa ServerWebExchange (que es el objeto que representa el intercambio request response)
        y contiene la request, cookies y todo basicamente y la filter chain (como en Oncerper..)  pero se llama webfilterchain, y se hace lo mismo de al final usar la filterchain con filter
        para pasar al siguiente filtro.

       - Implementación de un token de authenticacion JwtAuthenticationToken
        He tenido que implementar un JwtAuthenticationToken, que extiende de abstractAuthentication token y lo único que hace es guardar el token y el usuario (extraido del token)
        ya que en los filtros para que spring boot pueda tomar a un usuario por "autentificado" hay que añadir una implementación Authorization. Lo mismo que via a tener que hacer en login vamos.
        Esto en laravel era más facil, porque usabas Auth::Attempt y no implementabas manager ninguno pa el token se usaba  $token = $request->user()->createToken($request->token_name);
        y a chuparla. pero bueno aquí hay que implementar el token si no quieres usar oauth.


       Una vez implementado el filtro y el token necesito ponerlo en la cadena de filtros, para eso uso en http.addFilterBefore(elfiltro, SecurityWebFilterOrder.AUTHENTICATION)
       el securitywebfilterorder es un enum que tiene todas las fases. (menos mal no quería implementar nada más)
